---
title: "Help_Frontiers_Ecosystem_APT"
author: "Colas Guillon"
date: "2025-01-28"
output: html_document
---
# Set Up
### This loads the packages
```{r, Library import}
rm(list = ls())
library(terra)#package to read rasters
library(sf) #package to read vectors in a data frame format
library(ggplot2)
library(dplyr)
library(xts)
library(tidyr)
library(readr)
```

### Import the data 
NDVI = 230 layers
CHIRPS = 720
```{r, Open study area}
# Rasters
lulc_mcc <-rast("./rasters/LULC_MCC.tif") # Values are NaN, 1, 3, 51, 53, 52, 7, 6, 10, 43, 42, 41, 2
lulc_kariba <- rast("./Rasters/detailled_LULC_Kariba_area.tif") # Values are 4, 2, 5, 7, 3, 1, 10, 6, NaN
ndvi <- rast("./rasters/NDVI.tif")
chirps <- rast("./rasters/CHIRPS_pentad.tif")

# Load Vectors
study_area <- vect("./Shapefile/Zone_etude_Kariba_lake.shp")
mcc <- vect("./Shapefile/MCC.shp")
protected_areas <- vect("./Shapefile/protected_areas.shp")

# Reproject vectors
study_area<- project(study_area, ndvi)
mcc<-project(mcc, ndvi)
protected_areas<-project(protected_areas, ndvi)

# Load the CSVs
mcc_41_ET_csv <- read_csv("./CSVs/41ET_Table.csv", col_types = cols(.geo = col_skip())) 
mcc_42_ET_csv <- read_csv("./CSVs/42ET_Table.csv", col_types = cols(.geo = col_skip())) 
mcc_43_ET_csv <- read_csv("./CSVs/43ET_Table.csv", col_types = cols(.geo = col_skip())) 
mcc_51_ET_csv <- read_csv("./CSVs/51ET_Table.csv", col_types = cols(.geo = col_skip())) 
mcc_52_ET_csv <- read_csv("./CSVs/52ET_Table.csv", col_types = cols(.geo = col_skip())) 
mcc_53_ET_csv <- read_csv("./CSVs/53ET_Table.csv", col_types = cols(.geo = col_skip())) 
mcc_crop_ET_csv <- read_csv("./CSVs/CropET_Table.csv", col_types = cols(.geo = col_skip())) 
mcc_rip_ET_csv <- read_csv("./CSVs/RipET_Table.csv", col_types = cols(.geo = col_skip())) 
# Combine CSVs into One DF

```

# First Plots
```{r}'''
plot(ndvi)

# Plot
plot(lulc_mcc)
plot(study_area, add=T)

# Plot
plot(study_area)
plot(lulc_mcc)
plot(study_area, add = T)

# Convert raster grid to polygons
grid_polygons <- as.polygons(chirps)

# Plot the base raster first
plot(lulc_mcc, main="Raster with Transparent Grid Overlay")
plot(grid_polygons, add=TRUE, border="black", col=NA, lwd=0.5)

image(chirps, col=NA, add=TRUE)  # This prevents actual cell coloring
drawGrid(chirps, col="black", lwd=0.5)'''
```

# Define function to automate data processing
```{r}
# Define function 
process_raster <- function(raster, ref_raster, study_area){
  if ((res(raster)[1]) > (res(ref_raster)[1])){
    raster_aligned <- resample(raster, ref_raster, method="bilinear")
  }else {
    raster_aligned <- project(raster, ref_raster, method = "near")
  }
  raster_masked <- raster_aligned %>%
  crop(study_area) %>%
  mask(study_area) 
  return(raster_masked)
}
```

# Apply the function to project, clip and mask all the data
```{r}
chirps_masked <- process_raster(chirps, ndvi, study_area)
lulc_kariba_masked <- process_raster(lulc_kariba, ndvi, study_area)
lulc_mcc_masked <- process_raster(lulc_mcc, ndvi, study_area)
ndvi_masked <- process_raster(ndvi, ndvi, study_area)
```

### Isolate each of the landcover classes from Kariba
```{r}
# Extract the indices of the cells which are of each land-cover type
miombo_kariba <- which(lulc_kariba_masked[]==4) #we select the type of forests
mopane_kariba <- which(lulc_kariba_masked[]==5)
riparian_kariba <- which(lulc_kariba_masked[]==7)
crop_kariba <- which(lulc_kariba_masked[]==2)
all_kariba <- which(!is.na(values(lulc_mcc_masked)))

list_kariba <- list(miombo_kariba = miombo_kariba, 
                    mopane_kariba = mopane_kariba, 
                    riparian_kariba=riparian_kariba, 
                    crop_kariba=crop_kariba,
                    all_kariba = all_kariba)
```

### Isolate each of the landcover classes from the MCC 
```{r}
# Extract the indices of the cells which are of each landcover type
# Unique values are: 1, 3, 51, 53, 52, 7, 6, 10, 43, 42, 41, 2
miombo_mcc_all <- which(lulc_mcc_masked[]==41 | lulc_mcc_masked[]==42 | lulc_mcc_masked[]==43)
miombo_mcc_41<- which(lulc_mcc_masked[]==41)
miombo_mcc_42<- which(lulc_mcc_masked[]==42)
miombo_mcc_43<- which(lulc_mcc_masked[]==43) 
mopane_mcc_all <- which(lulc_mcc_masked[]==51 | lulc_mcc_masked[]==52 | lulc_mcc_masked[]==53)
mopane_mcc_51<- which(lulc_mcc_masked[]==51)
mopane_mcc_52 <- which(lulc_mcc_masked[]==52)
mopane_mcc_53 <- which(lulc_mcc_masked[]==53)
riparian_mcc <- which(lulc_mcc_masked[]==7)
crop_mcc <- which(lulc_mcc_masked[]==2)
all_mcc <- which(!is.na(values(lulc_mcc_masked)))

list_mcc <- list(
  miombo_mcc_all = miombo_mcc_all,
  miombo_mcc_41 = miombo_mcc_41, 
  miombo_mcc_42 = miombo_mcc_42, 
  miombo_mcc_43 = miombo_mcc_43, 
  mopane_mcc_all = mopane_mcc_all,
  mopane_mcc_51 = mopane_mcc_51, 
  mopane_mcc_52 = mopane_mcc_52, 
  mopane_mcc_53 = mopane_mcc_53, 
  riparian_mcc = riparian_mcc, 
  crop_mcc = crop_mcc,
  all_mcc = all_mcc
)
```

### Extract the dates from the NDVI
```{r, dates}
# This extracts the dates as a character string
ndvi.dates=names(ndvi_masked) #Extract the name of ndvi bands
# Because there the format is 2015_03_18_NDVI, we want to get rid of the NDVI
# Therefore we remove it using sub()
dates = sub("_NDVI", "", ndvi.dates) #we keep only the date
# Then we convert the character string into a date format object
ndvi_dates <- as.Date(dates,"%Y_%m_%d") #put in date format
```

### Extract Chirps Dates
```{r}
chirps_dates=names(chirps_masked) #Extract the name of ndvi bands
chirps_dates = sub("_precipitation", "", chirps_dates) #we keep only the date
chirps_dates <- as.Date(chirps_dates,"%Y%m%d")
```

# 
```{r}
extract_means <- function(list_indexes, raster, dates){
  
# First set up the output df
col_names <- names(list_indexes)   # Extract the names of the objects dynamically
output_df <- data.frame(matrix(ncol = length(col_names), nrow = length(dates))) # Create an empty dataframe with these column names
colnames(output_df) <- col_names # Set the df to take the names from the list
rownames(output_df) <- dates

# Now loop through the list and calculate the mean of each date for each land cover
  for (name in col_names){
    # Extract the means
    i <- list_indexes[[name]]
    df <- raster[i] # Extract the values of NDVI for the right cells using the index, store as dataframe with each date being a column
    col_mean <- colMeans(df, na.rm=T) #Take a mean of each column in the dataframe (i.e the date)
    output_df[[name]] <- col_mean # Add each vector of means to the columns in the df
  }
return(output_df)
}
```

# Use the function to get the mean of each raster for each land cover
```{r}
# MCC 
ndvi_mcc_df <- extract_means(list_mcc, ndvi_masked, ndvi_dates)
chirps_mcc_df <- extract_means(list_mcc, chirps_masked, chirps_dates)

#Kariba
ndvi_kariba_df <- extract_means(list_kariba, ndvi_masked, ndvi_dates)
chirps_kariba_df <- extract_means(list_kariba, chirps_masked, chirps_dates)

head(ndvi_mcc_df)
```
###  Plot NDVI vs Time - MCC
```{r}
# Convert rownames (dates) to a proper column
chirps_df_mcc_long <- chirps_mcc_df %>%
  mutate(Date = as.Date(rownames(chirps_mcc_df))) %>%
  pivot_longer(cols = -Date, names_to = "Land_Cover", values_to = "chirps_Mean")

# Plot using ggplot2
ggplot(chirps_df_mcc_long, aes(x = Date, y = chirps_Mean, color = Land_Cover)) +
  geom_line(linewidth = 0.5) +
  labs(title = "chirps Mean Over Time",
       x = "Date",
       y = "chirps Mean",
       color = "Land Cover Type") +
  theme_minimal()
```

#Process Timeseries to Remove Small Scale Variability
## NDVI 
###Convert into a timeseries object and Smooth It
This takes an average of the 
```{r}
ndvi_xts <- xts(Miombo.NDVI.mean, order.by=ndvi_dates)
# Plot original data

# Apply a 30-day rolling mean to smooth short-term noise
ndvi_smoothed <- rollapply(ndvi_xts, width=2, FUN=mean, align="center", fill=NA)

# Plot smoothed time series
plot(ndvi_xts, main="NDVI Smoothed (5-frame Rolling Mean)", col="gray")
lines(ndvi_smoothed, col="red", lwd=2) # Overlay smoothed series
```

## CHIRPS
```{r}
rain_xts <- xts(miombo.rain.mean, order.by=rain.dates)
# Plot original data

# Apply a 30-day rolling mean to smooth short-term noise
rain_smoothed <- rollapply(rain_xts, width=15, FUN=mean, align="center", fill=NA)

# Plot smoothed time series
plot(rain_xts, main="rain Smoothed (5-frame Rolling Mean)", col="gray")
lines(rain_smoothed, col="red", lwd=2)  # Overlay smoothed series
```




