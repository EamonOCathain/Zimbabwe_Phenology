---
title: "Help_Frontiers_Ecosystem_APT"
author: "Colas Guillon"
date: "2025-01-28"
output: html_document
---
# Set Up
### This loads the packages
```{r, Library import}
rm(list = ls())
library(terra)#package to read rasters
library(sf) #package to read vectors in a data frame format
library(ggplot2)
library(dplyr)
library(xts)
```

### Import the data 
NDVI = 230 layers
CHIRPS = 720
```{r, Open study area}
# Rasters
lulc_mcc <-rast("./rasters/LULC_MCC.tif") # Values are NaN, 1, 3, 51, 53, 52, 7, 6, 10, 43, 42, 41, 2
lulc_kariba <- rast("./Rasters/detailled_LULC_Kariba_area.tif") # Values are 4, 2, 5, 7, 3, 1, 10, 6, NaN
ndvi <- rast("./rasters/NDVI.tif")
chirps <- rast("./rasters/CHIRPS_pentad.tif")

# Load Vectors
study_area <- vect("./Shapefile/Zone_etude_Kariba_lake.shp")
mcc <- vect("./Shapefile/MCC.shp")
protected_areas <- vect("./Shapefile/protected_areas.shp")

# Reproject vectors
study_area<- project(study_area, ndvi)
mcc<-project(mcc, ndvi)
protected_areas<-project(protected_areas, ndvi)
```

# First Plots
```{r}'''
plot(ndvi)

# Plot
plot(lulc_mcc)
plot(study_area, add=T)

# Plot
plot(study_area)
plot(lulc_mcc)
plot(study_area, add = T)

# Convert raster grid to polygons
grid_polygons <- as.polygons(chirps)

# Plot the base raster first
plot(lulc_mcc, main="Raster with Transparent Grid Overlay")
plot(grid_polygons, add=TRUE, border="black", col=NA, lwd=0.5)

image(chirps, col=NA, add=TRUE)  # This prevents actual cell coloring
drawGrid(chirps, col="black", lwd=0.5)'''
```

# Define function to automate data processing
```{r}
# Define function 
process_raster <- function(raster, ref_raster, study_area){
  if ((res(raster)[1]) > (res(ref_raster)[1])){
    raster_aligned <- resample(raster, ref_raster, method="bilinear")
  }else {
    raster_aligned <- project(raster, ref_raster, method = "near")
  }
  raster_masked <- raster_aligned %>%
  crop(study_area) %>%
  mask(study_area) 
  return(raster_masked)
}
```

# Apply the function to project, clip and mask all the data
```{r}
chirps_masked <- process_raster(chirps, ndvi, study_area)
lulc_kariba_masked <- process_raster(lulc_kariba, ndvi, study_area)
lulc_mcc_masked <- process_raster(lulc_mcc, ndvi, study_area)
ndvi_masked <- process_raster(ndvi, ndvi, study_area)
```

### Isolate each of the landcover classes from Kariba
```{r}
# Extract the indices of the cells which are of each land-cover type
miombo_kariba <- which(lulc_kariba_masked[]==4) #we select the type of forests
mopane_kariba <- which(lulc_kariba_masked[]==5)
riparian_kariba <- which(lulc_kariba_masked[]==7)
crop_kariba <- which(lulc_kariba_masked[]==2)

list_kariba <- list(miombo_kariba = miombo_kariba, 
                    mopane_kariba = mopane_kariba, 
                    riparian_kariba=riparian_kariba, 
                    crop_kariba=crop_kariba)
```

### Isolate each of the landcover classes from the MCC 
```{r}
# Extract the indices of the cells which are of each landcover type
# Unique values are: 1, 3, 51, 53, 52, 7, 6, 10, 43, 42, 41, 2
miombo_mcc_41<- which(lulc_mcc_masked[]==41)
miombo_mcc_42<- which(lulc_mcc_masked[]==42)
miombo_mcc_43<- which(lulc_mcc_masked[]==43) 
mopane_mcc_51<- which(lulc_mcc_masked[]==51)
mopane_mcc_52 <- which(lulc_mcc_masked[]==52)
mopane_mcc_53 <- which(lulc_mcc_masked[]==53)
riparian_mcc <- which(lulc_mcc_masked[]==7)
crop_mcc <- which(lulc_mcc_masked[]==2)

list_mcc <- list(
  miombo_mcc_41 = miombo_mcc_41, 
  miombo_mcc_42 = miombo_mcc_42, 
  miombo_mcc_43 = miombo_mcc_43, 
  mopane_mcc_51 = mopane_mcc_51, 
  mopane_mcc_52 = mopane_mcc_52, 
  mopane_mcc_53 = mopane_mcc_53, 
  riparian_mcc = riparian_mcc, 
  crop_mcc = crop_mcc
)
```

### Extract the dates from the NDVI
```{r, dates}
# This extracts the dates as a character string
ndvi.dates=names(ndvi_masked) #Extract the name of ndvi bands
# Because there the format is 2015_03_18_NDVI, we want to get rid of the NDVI
# Therefore we remove it using sub()
dates = sub("_NDVI", "", ndvi.dates) #we keep only the date
# Then we convert the character string into a date format object
ndvi_dates <- as.Date(dates,"%Y_%m_%d") #put in date format
```

### Extract Chirps Dates
```{r}
chirps_dates=names(chirps_masked) #Extract the name of ndvi bands
chirps_dates = sub("_precipitation", "", chirps_dates) #we keep only the date
chirps_dates <- as.Date(chirps_dates,"%Y%m%d")
```

# 
```{r}
extract_means <- function(list_indexes, raster, dates){
  
# First set up the output df
col_names <- names(list_indexes)   # Extract the names of the objects dynamically
output_df <- data.frame(matrix(ncol = length(col_names), nrow = length(dates))) # Create an empty dataframe with these column names
colnames(output_df) <- col_names # Set the df to take the names from the list
rownames(output_df) <- dates

# Now loop through the list and calculate the mean of each date for each land cover
  for (name in col_names){
    # Extract the means
    i <- list_indexes[[name]]
    df <- raster[i] # Extract the values of NDVI for the right cells using the index, store as dataframe with each date being a column
    col_mean <- colMeans(df, na.rm=T) #Take a mean of each column in the dataframe (i.e the date)
    output_df[[name]] <- col_mean # Add each vector of means to the columns in the df
  }
return(output_df)
}
```

# Use the function to get the mean of each raster for each land cover
```{r}
# MCC 
ndvi_mcc_df <- extract_means(list_mcc, ndvi_masked, ndvi_dates)
chirps_mcc_df <- extract_means(list_mcc, chirps_masked, chirps_dates)

#Kariba
ndvi_kariba_df <- extract_means(list_kariba, ndvi_masked, ndvi_dates)
chirps_kariba_df <- extract_means(list_kariba, chirps_masked, chirps_dates)


```


### Plot NDVI vs Time
```{r,plot}
# Put the data into a dataframe
ndvi_mean=data.frame("dates"=ndvi_dates,"Miombo"=Miombo.NDVI.mean,"Mopane"=Mopane.NDVI.mean,"Riparian"=Riparian.NDVI.mean,"Crop"=crop.NDVI.mean)#we put it in the same data frame

ndvi_long <- ndvi_mean %>% # we put it in a long format
  tidyr::pivot_longer(cols = c(Miombo, Mopane, Riparian,Crop), 
               names_to = "Type", 
               values_to = "NDVI")
ggplot(ndvi_long,aes(x=dates,y=NDVI,color=Type))+ 
  geom_line()+
  scale_color_manual(values = c("Miombo" = "green", "Mopane" = "forestgreen", "Riparian" = "lightblue","Crop"="orange")) +  
  labs(title = "Change in NDVI", x = "Date", y = "NDVI", color = "Vegetation") + 
  theme_minimal()
```



### Plot Rain vs Time
```{r,plot}
# Put the data into a dataframe
rain_mean=data.frame("dates"=rain.dates,"Miombo"=miombo.rain.mean,"Mopane"=mopane.rain.mean,"Riparian"=riparian.rain.mean,"Crop"=crop.rain.mean)#we put it in the same data frame

# Pivot the dataframe into a long one
rain_long <- rain_mean %>% # we put it in a long format
  tidyr::pivot_longer(cols = c(Miombo, Mopane, Riparian,Crop), 
               names_to = "Type", 
               values_to = "rain")

# Plot the rain vs time
ggplot(rain_long,aes(x=dates,y=rain,color=Type))+ 
  geom_line()+
  scale_color_manual(values = c("Miombo" = "green", "Mopane" = "forestgreen", "Riparian" = "lightblue","Crop"="orange")) +  
  labs(title = "Évolution du rain", x = "Date", y = "rain", color = "Végétation") + 
  theme_minimal()
```

#Process Timeseries to Remove Small Scale Variability
## NDVI 
###Convert into a timeseries object and Smooth It
This takes an average of the 
```{r}
ndvi_xts <- xts(Miombo.NDVI.mean, order.by=ndvi_dates)
# Plot original data

# Apply a 30-day rolling mean to smooth short-term noise
ndvi_smoothed <- rollapply(ndvi_xts, width=2, FUN=mean, align="center", fill=NA)

# Plot smoothed time series
plot(ndvi_xts, main="NDVI Smoothed (5-frame Rolling Mean)", col="gray")
lines(ndvi_smoothed, col="red", lwd=2) # Overlay smoothed series
```
# NDVI Trend
```{r}
ndvi_trend <- lm(ndvi_smoothed ~ )
```

## CHIRPS
```{r}
rain_xts <- xts(miombo.rain.mean, order.by=rain.dates)
# Plot original data

# Apply a 30-day rolling mean to smooth short-term noise
rain_smoothed <- rollapply(rain_xts, width=15, FUN=mean, align="center", fill=NA)

# Plot smoothed time series
plot(rain_xts, main="rain Smoothed (5-frame Rolling Mean)", col="gray")
lines(rain_smoothed, col="red", lwd=2)  # Overlay smoothed series
```

# His script on CHIRPS
### Take the monthly mean of rainfall - Do we want to do this?
```{r}
# Conversion to Monthly Sum
rain.miombo.mean=colMeans(rain.miombo,na.rm=T) # Mean of rain over miombo
rain.miombo.monthly=aggregate(rain.miombo.mean,by=list(format(dates_formattees,"%Y %m")),sum,na.rm=T) %>% 
  rename("Date"=Group.1,"Rain_miombo"=x)

rain.mopane.mean=colMeans(rain.mopane,na.rm=T) 
rain.mopane.monthly=aggregate(rain.mopane.mean,by=list(format(dates_formattees,"%Y %m")),sum,na.rm=T) %>% 
  rename("Date"=Group.1,"Rain_mopane"=x)

rain.crop.mean=colMeans(rain.crop,na.rm=T) 
rain.crop.monthly=aggregate(rain.crop.mean,by=list(format(dates_formattees,"%Y %m")),sum,na.rm=T) %>% 
  rename("Date"=Group.1,"Rain_crop"=x)

rain=merge(rain.miombo.monthly,rain.mopane.monthly,by="Date")
rain=merge(rain,rain.crop.monthly,by="Date")
rain_long=tidyr::pivot_longer(rain,cols = c(Rain_miombo,Rain_mopane,Rain_crop), 
               names_to = "Type of forest", values_to = "Rain")
# Plot
ggplot(tail(rain_long,36),aes(x=Date,y=Rain,fill=`Type of forest`))+ # 36 last rows gives you 2024
  geom_col(position="dodge") #on prend que les données de 2024
```

### Correlation of rainfall and NDVI
```{r} 
#exploration de la corrélation entre pluie et ndvi
chirps_16_days <- tapp(chirps_masked, index = cut(1:nlyr(chirps_masked),length(dates_formattees)), fun = mean) # we need the rain (5 days) to fit with the ndvi (16 days)
cor(values(chirps_16_days),values(ndvi_masked),use="na.or.complete") #to dig if we want a correlation map
```

### Different types of forest in the MCC
```{r}
#We can work on the different types of forest in the MCC
miombo=which(lulc_mcc[]==41 | lulc_mcc[]==42 | lulc_mcc[]==43)
mopane=which(lulc_mcc[]==51 | lulc_mcc[]==52 | lulc_mcc[]==53)
riparian=which(lulc_mcc[]==7)
```



